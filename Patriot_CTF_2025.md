## Утилита hashcat + словарь rockyou.txt в задаче №1

### 1. Контекст задачи

В задаче №1 из отчёта по PatriotCTF у нас есть **хэш пароля** от аккаунта, и нужно этот пароль подобрать.

Одногруппник описывает, что:

* сначала пробовал собственный список из ~60 000 паролей **через свой скрипт** — пароль не нашёлся;
* затем запускал **hashcat**, но с тем же словарём это тоже не помогло;
* потом взял стандартный словарь `rockyou.txt` из каталога `/usr/share/wordlists/rockyou.txt.gz` и с ним уже получилось подобрать пароль и получить флаг `pctf{mr.krabbs57}`.

То есть главная утилита здесь — **hashcat**, а `rockyou.txt` — это «пища» для него, словарь паролей для перебора.

---

### 2. Пример команд

В отчёте конкретных команд нет, но по описанию можно восстановить типичный набор действий.

1. Разархивировать словарь `rockyou.txt.gz`:

```bash
gunzip /usr/share/wordlists/rockyou.txt.gz
```

2. Запустить `hashcat` на подбор пароля к нашему хэшу (допустим, хэш лежит в файле `hash.txt`):

```bash
hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt
```

Здесь:

* `-m 0` — тип хэша (обычный `MD5` как типичный пример; в реальной задаче тип может быть другим);
* `-a 0` — режим прямого перебора по словарю: каждый пароль из `rockyou.txt` просто по очереди проверяется.

3. После успешного подбора:

```bash
hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt --show
```

Эта команда показывает уже найденный пароль в удобном виде.

Я понимаю, что синтаксис у одногруппника мог чуть отличаться, но логика примерно такая: словарь → hashcat → подобрать → показать.

---

### 3. Подробный разбор работы утилиты

#### 3.1. Почему скрипт и первый словарь не сработали

По отчёту видно, что:

* использовался собственный список из ~60 000 паролей — скорее всего, это какой-то частый набор вроде «top10000», типовые комбинации, популярные слова;
* пароль `mr.krabbs57` — довольно специфичный (мультгерой + цифры), его, видимо, не было в этом списке.

То есть **сам подход верный**, но словарь слишком узкий.

Мой вывод как студента: если словарь мал, а пароль чуть более «фантазийный», наш скрипт просто не дойдёт до нужного значения — его в списке нет.

#### 3.2. Зачем нужен именно `rockyou.txt`

Файл `rockyou.txt` — это огромный набор реально утёкших паролей.

Для нас он полезен, потому что:

* содержит миллионы вариантов;
* там масса «человеческих» паролей с именами, прозвищами, героями мультиков и добавленными числами;
* такие пароли часто используются в задачах CTF, чтобы показать, как легко подобрать пароль, если пользователь не придумывает ничего нового, а берёт «из головы».

Пароль `mr.krabbs57` идеально вписывается в такую категорию: имя героя + цифры.

#### 3.3. Как работает `hashcat` с точки зрения логики

Если объяснить своими словами:

1. Я даю `hashcat`:

   * файл с хэшем `hash.txt`;
   * файл-словарь `rockyou.txt`;
   * указываю тип хэша (чтобы программа знала, как считать контрольную сумму).

2. `hashcat` берёт из словаря первый пароль, например `123456`:

   * считает от него хэш тем же алгоритмом;
   * сравнивает с нашим хэшом;
   * если не совпало — идёт к следующему слову.

3. Так продолжается, пока:

   * либо не найдётся слово, которое даёт совпадение хэша;
   * либо словарь не закончится.

Преимущество `hashcat` не только в том, что он «перебирает», но и в том, что делает это **очень быстро**, используя видеокарту и оптимизации.

#### 3.4. Как вставить это в отчёт со скриншотами

Я бы сделал так:

1. **Скриншот №1** — просмотр стандартного словаря:

   ```bash
   ls /usr/share/wordlists
   ```

   И отдельно вывод:

   ```bash
   zcat /usr/share/wordlists/rockyou.txt.gz | head
   ```

   Подпись:
   *Рисунок N — Стандартный словарь `rockyou.txt` в системе Kali Linux.*

2. **Скриншот №2** — запуск `hashcat` с этим словарём:

   ```bash
   hashcat -m <тип_хэша> -a 0 hash.txt /usr/share/wordlists/rockyou.txt
   ```

   Подпись:
   *Рисунок N+1 — Запуск hashcat с использованием словаря `rockyou.txt`.*

3. **Скриншот №3** — команда `--show` и результат с флагом.

   Подпись:
   *Рисунок N+2 — Вывод hashcat с подобранным паролем, где содержится флаг.*

---

### 4. Итог по утилите

Для меня как для студента 3 курса ИБ эта часть отчёта показывает важный момент:

* сам по себе скрипт для перебора — не главное;
* критично **какой словарь** мы используем.

Связка `hashcat + rockyou.txt` превращает задачу из бесконечного угадывания в вполне решаемую: мы опираемся на реальную статистику паролей и мощный инструмент, который умеет эти варианты быстро проверять.

В итоге одногруппник правильно сделал, что сменил словарь, а не попытался «усилить» первоначальный скрипт без достаточной базы паролей.

---

## Утилита steghide в задаче №3

### 1. Контекст задачи

В задаче №3 по PatriotCTF нам выдали **файл Word** (`.docx`), в котором на первый взгляд только текст про Спанч Боба.

Одногруппник в отчёте делает такие шаги:

* вспоминает, что `.docx` — это на самом деле архив формата ZIP;
* переименовывает файл и вскрывает содержимое;
* видит там несколько картинок;
* прогоняет эти картинки через утилиты `strings`, `exiftool`, `binwalk`, но флаг не находится;
* вспоминает про утилиту **steghide**, а в условии задачи прямо сказано, что пароль не требуется;
* запускает `steghide` для извлечения данных и получает файл с флагом.

То есть основная «волшебная» утилита здесь — **`steghide`**, программа для стеганографии.

---

### 2. Пример команд

По описанию в отчёте последовательность действий могла выглядеть так.

1. Переименовать `docx` в `zip` и извлечь:

```bash
mv challenge.docx challenge.zip
unzip challenge.zip -d docx_content
```

2. Посмотреть содержимое папки с картинками:

```bash
ls docx_content/word/media
```

3. Проверить одну из картинок стандартными утилитами (пример):

```bash
strings docx_content/word/media/image1.png | head
exiftool docx_content/word/media/image1.png
binwalk docx_content/word/media/image1.png
```

4. Попробовать `steghide` (без пароля, раз в условии написано «пароль не нужен»):

```bash
steghide extract -sf docx_content/word/media/image1.png -xf flag.txt
```

Если флаг спрятан именно в `image1.png`, программа без пароля извлечёт `flag.txt` в текущую директорию.

---

### 3. Подробный разбор работы steghide

#### 3.1. Что делает steghide

Своими словами:

* `steghide` умеет **прятать текстовые файлы внутрь изображений** (и не только) так, чтобы картинка с виду не изменилась;
* при извлечении программа вытаскивает спрятанный файл обратно;
* обычно для доступа нужен **пароль**, но в нашей задаче авторы прямо сказали, что пароль не используется.

В нашем случае одногруппник просто пытается извлечь данные **без пароля**, и это срабатывает.

#### 3.2. Разбор команды `steghide extract`

Команда:

```bash
steghide extract -sf image1.png -xf flag.txt
```

По частям:

* `extract` — режим извлечения спрятанных данных;
* `-sf image1.png` — «source file»: исходный файл-носитель, где, предполагается, спрятан флаг;
* `-xf flag.txt` — «extract file»: куда сохранить извлечённый поток данных (в данном случае под именем `flag.txt`).

Если пароль не нужен, `steghide` либо вообще его не спрашивает, либо позволяет просто нажать Enter, и извлечение пройдёт.

#### 3.3. Почему `strings`, `exiftool` и `binwalk` не помогли

В отчёте перечислены три утилиты, которые не дали результата:

* `strings` — пробегает по файлу и вытаскивает все читаемые фрагменты текста;
* `exiftool` — показывает служебные поля и метаданные (модель камеры, дату, комментарии и т.п.);
* `binwalk` — ищет «вложенные» форматы (например, ZIP внутри PNG).

Если стеганография сделана аккуратно, флаг:

* не лежит явным куском текста;
* не записан в понятное метаполе;
* не оформлен отдельным вложенным файлом.

Поэтому эти утилиты ничего не нашли, а `steghide` — нашёл, потому что **он знает конкретный формат встраивания**.

#### 3.4. Скриншоты для отчёта

Я бы показал:

1. **Скриншот №1** — содержимое `zip`-архива:

   ```bash
   unzip -l challenge.zip
   ```

   Подпись:
   *Рисунок N — Содержимое архива .docx: видно папку `word/media` с изображениями.*

2. **Скриншот №2** — попытка `strings`/`exiftool`/`binwalk`:

   ```bash
   strings image1.png | grep -i flag
   exiftool image1.png
   binwalk image1.png
   ```

   Подпись:
   *Рисунок N+1 — Проверка изображения стандартными утилитами, флаг не обнаружен.*

3. **Скриншот №3** — успешное извлечение `steghide`:

   ```bash
   steghide extract -sf image1.png -xf flag.txt
   cat flag.txt
   ```

   Подпись:
   *Рисунок N+2 — Извлечение спрятанного флага с помощью steghide.*

---

### 4. Итог по утилите

Как я это вижу:

* стандартные инструменты анализа файла (просмотр текста, метаданных, поиск вложенных структур) могут не показать ничего подозрительного;
* при этом специализированная стеганографическая утилита, вроде `steghide`, вытаскивает содержимое буквально одной командой, если мы догадались её использовать.

Для студента ИБ это хороший пример того, что:

* важно помнить о форматах файлов (docx как zip, изображения как контейнеры для данных);
* кроме обычного анализа, нужно держать в голове и **стеганографические утилиты**, особенно когда задача намекает на это прямо в условии.

---

## Утилита на Python для восстановления линейного генератора (Задача №5)

### 1. Контекст задачи

В задаче №5 одногруппнику дали:

* **шифртекст**;
* набор «утекших состояний» генератора.

По описанию видно, что:

* генератор описан формулой вида
  `S[n+1] = A * S[n] XOR B` над полем GF(2);
* `A` — это бинарная матрица 32×32;
* `B` — 32-битный вектор;
* каждое состояние — это 32 бита, которые дальше используются для построения потока и шифрования.

Задача утилиты:

1. по последовательности состояний восстановить матрицу `A` и вектор `B` (то есть полностью описать генератор);
2. с помощью восстановленного генератора построить поток битов нужной длины;
3. перевести поток в байты и **побайтно применить сложение по модулю 2 (XOR)** к шифртексту, чтобы получить флаг.

---

### 2. Основная структура скрипта

В отчёте приведены только описания шагов, поэтому код я восстанавливаю по смыслу. Структура утилиты получается примерно такой:

```python
def int_to_bits(x: int, n: int = 32) -> list[int]:
    ...

def bits_to_int(bits: list[int]) -> int:
    ...

def solve_GF2(matrix, rhs):
    # решение системы линейных уравнений над GF(2) методом Гаусса
    ...

def recover_A_B(states_bits):
    # восстановление матрицы A и вектора B по последовательности состояний
    ...

def generate_stream(A, B, S0_bits, length_bits):
    # построение потока битов заданной длины
    ...

def decrypt(cipher_bytes, keystream_bytes):
    # побайтовый XOR
    ...

def main():
    # 1. Загрузка утёкших состояний и перевод в биты
    # 2. Восстановление A и B
    # 3. Генерация потока
    # 4. XOR с шифртекстом
    ...
```

Дальше разбираю по частям.

---

### 3. Подробный разбор ключевых функций

#### 3.1. Перевод числа в массив битов и обратно

Чтобы работать над GF(2), всё удобнее хранить в виде **списка битов**.

```python
def int_to_bits(x: int, n: int = 32) -> list[int]:
    return [(x >> i) & 1 for i in range(n)]
```

* На вход подаётся целое число `x` (одно состояние) и длина `n = 32`.
* Сдвигая число вправо и беря младший бит, получаем каждый бит по очереди.
* Возвращаем список из 32 нулей и единиц.

Обратная операция:

```python
def bits_to_int(bits: list[int]) -> int:
    x = 0
    for i, b in enumerate(bits):
        x |= (b & 1) << i
    return x
```

* Идём по списку битов;
* собираем их обратно в целое число.

Так мы можем свободно «прыгать» между представлением числа и вектора в GF(2).

---

#### 3.2. Решение системы линейных уравнений над GF(2)

В отчёте упоминается функция `solve_GF2`, которая реализует **метод Гаусса по модулю 2**.

Смысл в том, что:

* сложение заменяется на XOR;
* умножение на числа — это просто `0` или оставление предыдущего значения;
* все коэффициенты — нули или единицы.

Утилита строит матрицу коэффициентов и столбец правых частей, а затем ищет решение.

Упрощённый вид функции:

```python
def solve_GF2(mat, rhs):
    n_rows = len(mat)
    n_cols = len(mat[0])
    # строим расширенную матрицу
    A = [row[:] + [rhs[i]] for i, row in enumerate(mat)]
    row = 0
    for col in range(n_cols):
        # поиск строки с единицей в текущем столбце
        pivot = None
        for r in range(row, n_rows):
            if A[r][col] == 1:
                pivot = r
                break
        if pivot is None:
            continue
        # меняем местами строки
        A[row], A[pivot] = A[pivot], A[row]
        # зануляем все остальные единицы в этом столбце
        for r in range(n_rows):
            if r != row and A[r][col] == 1:
                for c in range(col, n_cols + 1):
                    A[r][c] ^= A[row][c]
        row += 1
    # читаем решение (свободные переменные считаем нулём)
    solution = [0] * n_cols
    for r in range(n_rows):
        leading = None
        for c in range(n_cols):
            if A[r][c] == 1:
                leading = c
                break
        if leading is not None:
            solution[leading] = A[r][n_cols]
    return solution
```

Это стандартный метод Гаусса, только всё делается по модулю 2.

---

#### 3.3. Восстановление матрицы A и вектора B

По описанию из отчёта:

> Для каждой строки `i` матрицы `A` берём все пары последовательных состояний `S[n]`, `S[n+1]` и составляем уравнение
> `A_i * S[n] XOR b_i = S[n+1]_i`.

То есть:

* `A_i` — это i-я строка матрицы A (32 бита);
* `b_i` — i-й бит вектора B;
* `S[n]` и `S[n+1]` — известные состояния (нам их дали).

Для каждого `i`:

1. Строим систему уравнений по всем известным парам состояний:

   * левую часть `A_i * S[n] XOR b_i` выражаем через биты `A_i` и `b_i`;
   * правую часть — это просто i-й бит `S[n+1]`.

2. Решаем систему с помощью `solve_GF2`.

3. Получаем:

   * 32 бита строки `A_i`;
   * один бит `b_i`.

В псевдокоде:

```python
def recover_A_B(states_bits):
    A = []
    B = []
    for i in range(32):
        mat = []
        rhs = []
        for n in range(len(states_bits) - 1):
            S = states_bits[n]
            S_next = states_bits[n + 1]
            row = S[:] + [1]  # 32 бита для A_i + 1 бит для b_i
            mat.append(row)
            rhs.append(S_next[i])
        solution = solve_GF2(mat, rhs)
        A_i = solution[:32]
        b_i = solution[32]
        A.append(A_i)
        B.append(b_i)
    return A, B
```

---

#### 3.4. Генерация потока и расшифровка

Получив `A` и `B`, можно снова «запустить» генератор:

```python
def apply_transition(A, B, S):
    S_next = [0] * 32
    for i in range(32):
        s = 0
        for j in range(32):
            s ^= (A[i][j] & S[j])
        S_next[i] = s ^ B[i]
    return S_next
```

Здесь:

* `S` — текущее состояние в виде списка битов;
* для каждой строки `i`:

  * считаем скалярное произведение строки `A[i]` и вектора `S` по модулю 2 (то есть XOR по всем `j`, где оба бита равны 1);
  * добавляем бит `B[i]` по XOR.

Чтобы получить поток:

```python
def generate_stream(A, B, S0_bits, length_bits):
    S = S0_bits[:]
    stream = []
    while len(stream) < length_bits:
        S = apply_transition(A, B, S)
        stream.extend(S)
    return stream[:length_bits]
```

Когда у нас есть поток бит, мы превращаем его в байты и выполняем побайтовую операцию XOR с шифртекстом:

```python
def decrypt(cipher_bytes, keystream_bits):
    # переводим поток бит в байты
    keystream_bytes = []
    for i in range(0, len(keystream_bits), 8):
        byte_bits = keystream_bits[i:i+8]
        keystream_bytes.append(bits_to_int(byte_bits))
    # XOR
    res = bytes([c ^ k for c, k in zip(cipher_bytes, keystream_bytes)])
    return res
```

В отчёте одногруппник как раз пишет, что после этого **получает флаг**.

---

### 4. Итог по утилите

Для меня это пример «тяжёлой» утилиты на Python, которая:

1. автоматизирует работу с полем GF(2) — перевод чисел в биты и обратно;
2. решает систему линейных уравнений методом Гаусса по модулю 2;
3. восстанавливает внутренние параметры генератора (`A`, `B`);
4. полностью **воспроизводит поток** и дешифрует сообщение.

По сути, мы использовали протёкшие состояния как «подсказку» и достроили весь генератор. Это хороший пример применения чистой математики в практической криптоанализе, оформленный в виде удобного скрипта.

---

## Утилита на Python для обратного преобразования байтов (Задача №6)

### 1. Контекст задачи

В задаче №6 в отчёте описан файл `challenge.c`.

Эта программа выполняет над байтовым массивом несколько операций:

1. побитовое сложение по модулю 2 (XOR) с номером позиции;
2. добавление константы `MAGIC_ADD = 0x2A` к каждому байту;
3. перестановка (обмен местами соседних байтов);
4. ещё один XOR с циклическим ключом `XOR_KEY`.

Результат — «испорченный» буфер, который записывается в файл.

Наша задача — написать **обратную утилиту**, которая делает всё в обратном порядке и возвращает исходный текст (где лежит флаг).

---

### 2. Общая идея обратных действий

Одногруппник в отчёте правильно перечисляет обратные шаги:

Вперёд:

1. `buffer[i] ^= i;`
2. `buffer[i] = (buffer[i] + MAGIC_ADD) & 0xFF;`
3. `swap(buffer[i], buffer[i+1]);`
4. `buffer[i] ^= XOR_KEY[i % 5];`

Назад:

A. Обратный XOR с `XOR_KEY`
B. Обратный `swap` (он сам себе обратный)
C. Обратное вычитание `MAGIC_ADD`
D. Обратный XOR с позицией `i`

---

### 3. Пример утилиты на Python

Типичный скрипт для обратного преобразования мог выглядеть так:

```python
MAGIC_ADD = 0x2A
XOR_KEY = [0x12, 0x34, 0x56, 0x78, 0x9A]  # пример, реальные значения берутся из challenge.c

def undo_transform(buf: bytearray) -> bytearray:
    n = len(buf)

    # 1. Обратный XOR с циклическим ключом XOR_KEY (шаг 4 вперёд)
    for i in range(n):
        buf[i] ^= XOR_KEY[i % len(XOR_KEY)]

    # 2. Обратный swap (шаг 3 вперёд)
    # если вперёд шли по i = 0, 2, 4..., то назад делаем те же обмены
    for i in range(0, n - 1, 2):
        buf[i], buf[i + 1] = buf[i + 1], buf[i]

    # 3. Обратное вычитание MAGIC_ADD (шаг 2 вперёд был плюс)
    for i in range(n):
        buf[i] = (buf[i] - MAGIC_ADD) & 0xFF

    # 4. Обратный XOR с номером позиции (шаг 1 вперёд)
    for i in range(n):
        buf[i] ^= i

    return buf

def main():
    with open("enc.bin", "rb") as f:
        data = bytearray(f.read())

    plain = undo_transform(data)
    print(plain.decode(errors="ignore"))

if __name__ == "__main__":
    main()
```

---

### 4. Подробный разбор шагов

#### 4.1. Обратный XOR с ключом

```python
for i in range(n):
    buf[i] ^= XOR_KEY[i % len(XOR_KEY)]
```

* В прямом направлении к каждому байту добавляли XOR с элементом циклического ключа.
* XOR обратим сам к себе: если мы ещё раз применим тот же XOR, всё вернётся.
* Поэтому для отмены мы снова применяем `^= XOR_KEY[...]`.

#### 4.2. Обратный `swap`

```python
for i in range(0, n - 1, 2):
    buf[i], buf[i + 1] = buf[i + 1], buf[i]
```

* В прямом коде соседние байты менялись местами.
* Обмен местами — операция, которая сама себе обратна: дважды поменять — вернуться к исходному.
* Поэтому просто повторяем те же обмены, и порядок байтов восстанавливается.

#### 4.3. Обратное вычитание `MAGIC_ADD`

```python
for i in range(n):
    buf[i] = (buf[i] - MAGIC_ADD) & 0xFF
```

* В исходном `challenge.c` был шаг `+ MAGIC_ADD` (сложение по модулю 256).
* Чтобы вернуться назад, нужно выполнить вычитание по модулю 256, то есть `- MAGIC_ADD` с маской `& 0xFF`.
* Это стандартный приём для работы с байтами: результат всегда остаётся в диапазоне 0–255.

#### 4.4. Обратный XOR с индексом

```python
for i in range(n):
    buf[i] ^= i
```

* Перед шифрованием каждый байт менялся по формуле `^= i`, где `i` — его позиция в массиве.
* XOR, как и раньше, обратим сам к себе: ещё одно применение того же `^= i` вернёт исходный байт.

В результате после всех четырёх шагов буфер возвращается к тому состоянию, в котором он был **до запуска программы `challenge.c`**, и внутри становится виден флаг.

---

### 5. Итог по утилите

Эта утилита на Python по сути:

* аккуратно повторяет все шаги исходной C-программы, но **в обратном порядке**;
* использует тот же набор простых операций: побитовое сложение по модулю 2, сложение по модулю 256, обмен байтов.

Для меня как для студента ИБ это хороший пример того, как:

* прочитав исходный код на C,
* можно руками выписать обратные преобразования
* и оформить их в виде аккуратного скрипта для восстановления исходного текста и флага.

---

Если хочешь, дальше могу в таком же формате расписать ещё одну утилиту из того же отчёта — например, уже для Задачи №7, где порядок преобразований задан на Rust, и нужно аккуратно поменять местами все шаги шифрования.































