## Утилита на Python для расшифровки RC4-сервиса (задача №2)

### 1. Контекст задачи

Во второй задаче отчёта HeroCTF v7 одногруппнику дали онлайн-сервис шифрования на алгоритме RC4.

Особенности сервиса:

* он **шифрует флаг только при первом вводе выбранного нами ключа**;
* расшифрование не предоставляет;
* запрещает повторно использовать один и тот же ключ;
* в исходнике `chall.py` видно, что данные:

  1. сначала складываются с некой маской `MASK`,
  2. шифруются RC4,
  3. потом ещё раз складываются с той же `MASK`.

Одногруппник замечает, что математически это всё сводится просто к `флаг XOR ключевой_поток_RC4`, то есть по сути это «обычное» шифрование RC4 без настоящей соли и без защиты повторного использования ключа.

Задача утилиты:
**повторить у себя генерацию ключевого потока RC4 по выбранному ключу и, зная шифртекст, восстановить флаг**.

---

### 2. Сам программный код

Пример программы, которая делает то же самое, что описано в отчёте:

```python
def rc4_keystream(key: bytes, length: int) -> bytes:
    # Инициализация (KSA)
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]

    # Генерация потока байтов (PRGA)
    i = 0
    j = 0
    out = []
    for _ in range(length):
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        out.append(K)
    return bytes(out)

def decrypt_flag(cipher_hex: str, key_hex: str) -> str:
    # Шифртекст и ключ задаём в шестнадцатеричном виде
    cipher = bytes.fromhex(cipher_hex)
    key = bytes.fromhex(key_hex)

    # Строим ключевой поток той же длины, что шифртекст
    ks = rc4_keystream(key, len(cipher))

    # В отчёте показано, что лишние сложения с MASK сокращаются,
    # и остаётся обычное сложение по модулю 2 (XOR) с потоком RC4
    plain = bytes(c ^ k for c, k in zip(cipher, ks))

    return plain.decode(errors="ignore")

if __name__ == "__main__":
    # Пример: ключ, который мы отправляли сервису
    key_hex = "0011223344556677"
    # Здесь должен быть шифртекст, который вернул сервис
    cipher_hex = "..."  # скопировать из задания
    print(decrypt_flag(cipher_hex, key_hex))
```

---

### 3. Подробный разбор кода

#### 3.1. Функция rc4_keystream: генерация ключевого потока

```python
def rc4_keystream(key: bytes, length: int) -> bytes:
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]
```

Здесь реализована **начальная настройка RC4**:

* массив `S` — это перестановка чисел от 0 до 255;
* на каждом шаге эта перестановка «перемешивается» с помощью байтов ключа;
* в итоге получается внутренняя таблица, зависящая от ключа.

Дальше идёт **порождающая часть**:

```python
    i = 0
    j = 0
    out = []
    for _ in range(length):
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        out.append(K)
    return bytes(out)
```

На каждом шаге:

* немного перемешиваем массив `S`;
* по текущему состоянию выбираем один байт `K`;
* добавляем его в выходной поток.

Так формируется **ключевой поток RC4** длиной `length`.

#### 3.2. Функция decrypt_flag: отмена шифрования

```python
cipher = bytes.fromhex(cipher_hex)
key = bytes.fromhex(key_hex)
ks = rc4_keystream(key, len(cipher))
plain = bytes(c ^ k for c, k in zip(cipher, ks))
```

Здесь:

* переводим строковое шестнадцатеричное представление шифртекста и ключа в байты;
* строим ключевой поток той же длины, что и шифртекст;
* выполняем **побайтовое сложение по модулю 2 (операция исключающего ИЛИ)** между шифртекстом и ключевым потоком.

Так как в отчёте уже показано, что лишние сложения с маской `MASK` «сократились», у нас остаётся ровно операция:

> шифртекст = флаг XOR ключевой_поток
> значит, флаг = шифртекст XOR ключевой_поток.

Операция XOR сама себе обратная, поэтому второе сложение по модулю 2 полностью восстанавливает исходный текст.

---

### 4. Итог по утилите

Эта небольшая программа на Python показывает, что:

* попытка «усложнить» RC4 с помощью маски `MASK` ничего не даёт, если маска применяется «симметрично» до и после шифрования;
* достаточно один раз отправить выбранный ключ в сервис, сохранить шифртекст и затем **у себя** повторить работу RC4 и восстановить флаг.

Для меня как для студента ИБ это хороший пример того, как важно внимательно смотреть на формулы шифрования: иногда лишний слой «обработки» не добавляет реальной стойкости, а только создаёт иллюзию защиты.

---

## Утилита на Python для извлечения данных из LSB-стеганографии (задача №3)

### 1. Контекст задачи

В задаче №3 из отчёта HeroCTF v7 нам дали картинку. В условии сказано, что это **LSB-стеганография**: данные спрятаны в младших битах каналов цвета. Там же указано, что спрятанная область — это квадрат размером 100×100 пикселей.

Одногруппник описывает такой план:

* сначала вырезать нужный квадрат из картинки;
* затем с помощью библиотеки **PIL** в Python:

  * пройти по пикселям этого квадрата;
  * из каждого пикселя взять младший бит красного канала;
  * собрать эти биты в строку;
  * превратить эту строку битов в байты;
  * а байты — в символы.

Задача утилиты: **автоматически извлечь спрятанные данные из младших битов** и восстановить флаг.

---

### 2. Сам программный код

Пример программы на Python:

```python
from PIL import Image

def extract_lsb_from_square(path: str,
                            x0: int,
                            y0: int,
                            width: int,
                            height: int) -> bytes:
    img = Image.open(path)
    img = img.convert("RGB")

    bits = []

    for y in range(y0, y0 + height):
        for x in range(x0, x0 + width):
            r, g, b = img.getpixel((x, y))
            bit = r & 1
            bits.append(bit)

    # Преобразуем биты в байты
    data_bytes = []
    for i in range(0, len(bits), 8):
        byte_bits = bits[i:i+8]
        if len(byte_bits) < 8:
            break
        value = 0
        for b in byte_bits:
            value = (value << 1) | b
        data_bytes.append(value)
    return bytes(data_bytes)

if __name__ == "__main__":
    # Например, квадрат 100x100 с координат (X0, Y0)
    x0, y0 = 0, 0      # сюда подставить реальные координаты
    w, h = 100, 100

    hidden = extract_lsb_from_square("challenge.png", x0, y0, w, h)
    print(hidden.decode(errors="ignore"))
```

---

### 3. Подробный разбор кода

#### 3.1. Открытие изображения и подготовка

```python
img = Image.open(path)
img = img.convert("RGB")
```

* Открываем файл с картинкой.
* Приводим её к формату `RGB`, чтобы гарантированно иметь три канала: красный, зелёный, синий.

#### 3.2. Сбор младших битов

```python
bits = []

for y in range(y0, y0 + height):
    for x in range(x0, x0 + width):
        r, g, b = img.getpixel((x, y))
        bit = r & 1
        bits.append(bit)
```

Здесь:

* идём по строкам и столбцам в выбранном квадрате;
* для каждого пикселя берём компоненту `r` — красный канал;
* операция `r & 1` оставляет только младший бит (0 или 1);
* по сути, этот бит — один «кусочек» спрятанного сообщения;
* складываем все биты в один длинный список.

Так реализуется классическая **LSB-стеганография**: информация спрятана в младших битах цвета, визуально картинка почти не меняется.

#### 3.3. Преобразование битов в байты и текст

```python
data_bytes = []
for i in range(0, len(bits), 8):
    byte_bits = bits[i:i+8]
    if len(byte_bits) < 8:
        break
    value = 0
    for b in byte_bits:
        value = (value << 1) | b
    data_bytes.append(value)
return bytes(data_bytes)
```

Здесь:

* берём биты по 8 штук — один байт;
* собираем байт по принципу: сдвигаем значение влево и добавляем очередной бит;
* переводим список байтов в объект `bytes`;
* дальше в `main` пытаемся интерпретировать эти байты как текст (`decode`).

В отчёте одногруппник пишет, что после запуска такой программы он сразу увидел флаг.

---

### 4. Итог по утилите

Для меня эта программа — наглядный пример того, как:

* из обычного изображения можно по младшим битам восстановить спрятанный текст;
* библиотека `PIL` сильно упрощает работу с пикселями: не нужно вручную разбирать формат файла.

По сути, это универсальная утилита: если изменить координаты квадрата и порядок каналов, её можно применять и к другим задачам на LSB-стеганографию.

---

## Утилита с git-хуком и служебным архиватором (задача №4)

### 1. Контекст задачи

В задаче №4 в отчёте HeroCTF v7 нам дают доступ к удалённой системе по `ssh`, но:

* мы заходим только как пользователь `intern`;
* флаг лежит у пользователя `peter` в `/home/peter/flag.txt`;
* обычных прав для чтения этого файла у нас нет.

Зато у нас есть **служебный сценарий**, который:

1. распаковывает переданный архив `.tar.gz`;
2. заходит в распакованный каталог с проектом;
3. запускает `git add .`, `git commit` **от имени пользователя peter**.

Одногруппник замечает важную деталь: при `git commit` автоматически запускаются **обработчики `git hooks`**, в том числе `pre-commit`. Содержание `pre-commit` никак не проверяется, но выполняется от имени `peter`.

Идея утилиты:
**подсунуть такой репозиторий, где в `pre-commit` лежит команда, копирующая флаг в доступное место**.

---

### 2. Набор команд и служебный сценарий

Пример последовательности действий.

#### 2.1. Подготовка «злого» репозитория

На сервере:

```bash
# Скопировать исходный репозиторий, если защита не даёт его клонировать
cp -r /path/to/original_repo /home/intern/evilrepo

cd /home/intern/evilrepo
```

Создаём обработчик `pre-commit`:

```bash
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/sh
cp /home/peter/flag.txt /home/intern/flag.txt
EOF

chmod +x .git/hooks/pre-commit
```

Здесь `pre-commit` — это небольшая служебная программа, которая:

* перед каждым коммитом запускается автоматически;
* копирует флаг из домашнего каталога `peter` в домашний каталог `intern`.

#### 2.2. Упаковка репозитория в архив

```bash
cd /home/intern
tar czf evilrepo.tar.gz evilrepo
```

#### 2.3. Передача архива служебному сценарию

Теперь мы запускаем тот сценарий, который дал организатор, и передаём ему `evilrepo.tar.gz`. Он:

* распакует архив в нужное место;
* сделает `git add .`;
* выполнит `git commit` **от имени peter**;
* при этом сработает наш `pre-commit`, и флаг скопируется куда нам нужно.

После этого:

```bash
cat /home/intern/flag.txt
```

— и мы читаем флаг.

---

### 3. Подробный разбор

#### 3.1. Почему используется именно git-обработчик

`git commit` всегда:

* формирует новый снимок состояния проекта;
* перед этим запускает цепочку обработчиков из `.git/hooks`.

Обработчик `pre-commit`:

* выполняется **до** того, как коммит будет сформирован;
* если он завершается успешно, коммит продолжается;
* если завершается с ошибкой — коммита не будет.

В нашей задаче:

* содержимое обработчика никак не контролируется сервисом;
* он выполняется с правами того пользователя, от имени которого запущен `git commit` (здесь — `peter`).

Это даёт нам возможность:

> выполнить любую команду от имени `peter`, если мы подсовываем свой репозиторий с нужным содержимым `.git/hooks/pre-commit`.

#### 3.2. Почему клонирование было запрещено и как его обошли

В отчёте сказано, что при попытке обычного `git clone` включалась защита от подмены репозиториев.

Одногруппник обошёл это проще:

* взял уже существующий каталог с репозиторием;
* просто скопировал его целиком командой `cp -r`;
* после этого стал редактировать `.git/hooks/pre-commit`.

То есть он не создавал новый репозиторий через сетевой доступ, а работал с уже локальной копией.

#### 3.3. Почему команда копирования флага сработала

Сценарий `pre-commit` содержит:

```sh
cp /home/peter/flag.txt /home/intern/flag.txt
```

Когда служебный сценарий запускает `git commit` от имени `peter`:

* выполняется `pre-commit` **тоже от имени peter**;
* у этого пользователя есть права на чтение `/home/peter/flag.txt`;
* он спокойно копирует файл в домашний каталог `intern`;
* у нас уже достаточно прав, чтобы читать `/home/intern/flag.txt`.

Таким образом, мы не «ломаем» систему напрямую, а **используем уже существующий служебный механизм** для выполнения нужной команды.

---

### 4. Итог по утилите

Эта связка:

* служебный сценарий распаковки и коммита;
* наш `pre-commit` в `.git/hooks`;

по сути превращается в утилиту для **повышения привилегий через git-обработчик**.

Для меня как студента ИБ это хороший пример:

* как привычные инструменты разработчика (контроль версий) могут открыть путь к выполнению команд с чужими правами;
* почему важно контролировать содержимое служебных обработчиков и не запускать `git` вслепую от имени более привилегированного пользователя.

---

## Утилита на Python для восстановления флага из ELF (задача №5)

### 1. Контекст задачи

В задаче №5 нам дали:

* исполняемый файл формата ELF (32-разрядный);
* при просмотре строки флага в нём в чистом виде нет;
* в отчёте одногруппник пишет, что при анализе через Ghidra видно:
  флаг **собирается из нескольких функций-«ингредиентов»**, каждая возвращает несколько байтов.

То есть логика примерно такая:

* есть набор функций `part_0()`, `part_1()`, `part_2()` и т.п.;
* каждая из них возвращает массив байтов;
* где-то в программе эти массивы складываются в одну строку, которая и есть флаг.

Задача утилиты: **автоматически собрать все эти кусочки в нужном порядке и вывести флаг**.

---

### 2. Пример программной логики

Точный код из отчёта не приводится, но по описанию можно восстановить такой подход:

* из Ghidra или другого анализатора выгружается список функций с их адресами и содержимым массивов;
* мы записываем эти данные в Python в виде словаря;
* сортируем функции по адресу;
* последовательно конструируем флаг.

Пример:

```python
# Сюда вручную или через экспорт из Ghidra заносим данные:
# (адрес_функции, имя_функции, список байтов)
parts = [
    (0x08049000, "part_0", [0x70, 0x63, 0x74, 0x66]),         # "p", "c", "t", "f" ...
    (0x08049030, "part_1", [0x7B, 0x31, 0x6E, 0x67, 0x72]),   # "{", "1", "n", "g", "r" ...
    # и так далее, пока не выписаны все функции-«ингредиенты»
]

def build_flag(parts_info):
    # сортировка по адресу, как подчёркивает одногруппник в отчёте
    parts_sorted = sorted(parts_info, key=lambda x: x[0])

    result_bytes = []
    for addr, name, data in parts_sorted:
        result_bytes.extend(data)

    return bytes(result_bytes).decode(errors="ignore")

if __name__ == "__main__":
    flag = build_flag(parts)
    print(flag)
```

---

### 3. Подробный разбор

#### 3.1. Почему важен адрес функции

Одногруппник в отчёте отдельно подчёркивает:

> «нужно обязательно отсортировать по адресу».

Это связано с тем, что:

* в памяти программы функции располагаются по некоторым адресам;
* при сборке строки флага в бинарнике часто вызываются в **определённом порядке**;
* этот порядок зачастую совпадает с возрастанием адресов или явно задаётся.

Если мы перепутаем порядок, байты окажутся не на своих местах, и строка будет испорчена.

Поэтому:

```python
parts_sorted = sorted(parts_info, key=lambda x: x[0])
```

— это ключевой шаг: мы приводим функции-«ингредиенты» в то же расположение, как в виде машинного кода.

#### 3.2. Сборка байтов и перевод в строку

```python
result_bytes = []
for addr, name, data in parts_sorted:
    result_bytes.extend(data)

return bytes(result_bytes).decode(errors="ignore")
```

Здесь всё просто:

* берём по очереди массив байтов из каждой части;
* складываем их в один длинный список;
* переводим список в объект `bytes`;
* пробуем интерпретировать его как текст (обычно это латинские буквы и знаки, то есть обычная строка с флагом).

Если всё сделано правильно, на выходе получается строка вида:

```text
pctf{...}
```

или аналогичный флаг.

---

### 4. Итог по утилите

Эта утилита показывает, как можно:

* не искать флаг в чистом виде внутри ELF-файла;
* а аккуратно прочитать структуру программы (через Ghidra или другой дизассемблер);
* перенести найденные данные в свою небольшую программу на Python;
* и уже у себя восстановить итоговую строку.

Для меня как студента ИБ такая задача хорошо тренирует:

* чтение псевдокода после дизассемблирования;
* понимание того, как данные собираются во время выполнения;
* умение превратить наблюдения из анализатора в понятный и аккуратный восстановительный инструмент на Python.

---

Если захочешь, можем по этому же шаблону дальше разобрать утилиты из других отчётов (например, HeroCTF для бинарных задач или дополнительные приёмы для анализа сетевых сервисов).
